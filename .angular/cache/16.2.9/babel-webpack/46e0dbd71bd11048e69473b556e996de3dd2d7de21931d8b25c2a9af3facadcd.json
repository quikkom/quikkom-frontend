{"ast":null,"code":"import _asyncToGenerator from \"/home/alha/Project/quikkom-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, Optional, SkipSelf, Injector, ElementRef, runInInjectionContext, Component, ChangeDetectionStrategy, Input, HostBinding, NgModule, Inject } from '@angular/core';\nimport { isObservable, firstValueFrom } from 'rxjs';\nconst NgIconConfigToken = new InjectionToken('Ng Icon Config');\nconst defaultConfig = {\n  size: '1em'\n};\n/**\n * Provide the configuration for the icons\n * @param config The configuration to use\n */\nfunction provideNgIconsConfig(config) {\n  return {\n    provide: NgIconConfigToken,\n    useValue: {\n      ...defaultConfig,\n      ...config\n    }\n  };\n}\n/**\n * Inject the configuration for the icons\n * @returns The configuration to use\n * @internal\n */\nfunction injectNgIconConfig() {\n  return inject(NgIconConfigToken, {\n    optional: true\n  }) ?? defaultConfig;\n}\nconst NgIconLoaderToken = new InjectionToken('Ng Icon Loader Token');\n/**\n * Helper function to create an object that represents a Loader feature.\n */\nfunction loaderFeature(kind, providers) {\n  return {\n    kind: kind,\n    providers: providers\n  };\n}\nconst NgIconCacheToken = new InjectionToken('Ng Icon Cache Token');\n/**\n * Add caching to the loader. This will prevent the loader from being called multiple times for the same icon name.\n */\nfunction withCaching() {\n  return loaderFeature(0 /* NgIconLoaderFeatureKind.CachingFeature */, [{\n    provide: NgIconCacheToken,\n    useValue: new Map()\n  }]);\n}\n/**\n * Provide a function that will return the SVG content for a given icon name.\n * @param loader The function that will return the SVG content for a given icon name.\n * @param features The list of features to apply to the loader.\n * @returns The SVG content for a given icon name.\n */\nfunction provideNgIconLoader(loader, ...features) {\n  return [{\n    provide: NgIconLoaderToken,\n    useValue: loader\n  }, features.map(feature => feature.providers)];\n}\n/**\n * Inject the function that will return the SVG content for a given icon name.\n */\nfunction injectNgIconLoader() {\n  return inject(NgIconLoaderToken, {\n    optional: true\n  });\n}\n/**\n * Inject the cache that will store the SVG content for a given icon name.\n */\nfunction injectNgIconLoaderCache() {\n  return inject(NgIconCacheToken, {\n    optional: true\n  });\n}\n\n/**\n * Define the icons to use\n * @param icons The icons to provide\n */\nfunction provideIcons(icons) {\n  return [{\n    provide: NgIconsToken,\n    useFactory: parentIcons => ({\n      ...parentIcons?.reduce((acc, icons) => ({\n        ...acc,\n        ...icons\n      }), {}),\n      ...icons\n    }),\n    deps: [[NgIconsToken, new Optional(), new SkipSelf()]],\n    multi: true\n  }];\n}\nconst NgIconsToken = new InjectionToken('Icons Token');\n/**\n * Inject the icons to use\n * @returns The icons to use\n * @internal\n */\nfunction injectNgIcons() {\n  return inject(NgIconsToken, {\n    optional: true\n  }) ?? [];\n}\n\n/**\n * A loader may return a promise, an observable or a string. This function will coerce the result into a promise.\n * @returns\n */\nfunction coerceLoaderResult(result) {\n  if (typeof result === 'string') {\n    return Promise.resolve(result);\n  }\n  if (isObservable(result)) {\n    return firstValueFrom(result);\n  }\n  return result;\n}\n\n/**\n * Hyphenated to lowerCamelCase\n */\nfunction toPropertyName(str) {\n  return str.replace(/([^a-zA-Z0-9])+(.)?/g, (_, __, chr) => chr ? chr.toUpperCase() : '').replace(/[^a-zA-Z\\d]/g, '').replace(/^([A-Z])/, m => m.toLowerCase());\n}\nclass NgIcon {\n  constructor() {\n    /** Access the global icon config */\n    this.config = injectNgIconConfig();\n    /** Access the icons */\n    this.icons = injectNgIcons();\n    /** Access the icon loader if defined */\n    this.loader = injectNgIconLoader();\n    /** Access the icon loader cache if defined */\n    this.cache = injectNgIconLoaderCache();\n    /** Access the injector */\n    this.injector = inject(Injector);\n    /** Access the element ref */\n    this.elementRef = inject(ElementRef);\n    this._size = this.config.size;\n    /** Define the color of the icon */\n    this.color = this.config.color;\n  }\n  /** Define the name of the icon to display */\n  set name(name) {\n    this.setIcon(name);\n  }\n  /** Define the size of the icon */\n  set size(size) {\n    // if the size only contains numbers, assume it is in pixels\n    this._size = coerceCssPixelValue(size);\n  }\n  get size() {\n    return this._size;\n  }\n  /**\n   * Load the icon with the given name and insert it into the template.\n   * @param name The name of the icon to load.\n   */\n  setIcon(name) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const propertyName = toPropertyName(name);\n      for (const icons of [..._this.icons].reverse()) {\n        if (icons[propertyName]) {\n          // insert the SVG into the template\n          _this.elementRef.nativeElement.innerHTML = icons[propertyName];\n          return;\n        }\n      }\n      // if we have a cache check if the icon is already loaded\n      if (_this.cache?.has(name)) {\n        _this.elementRef.nativeElement.innerHTML = _this.cache.get(name);\n        return;\n      }\n      // if there is a loader defined, use it to load the icon\n      if (_this.loader) {\n        const result = yield _this.requestIconFromLoader(name);\n        // if the result is a string, insert the SVG into the template\n        if (result !== null) {\n          // if we have a cache, store the result\n          _this.cache?.set(name, result);\n          _this.elementRef.nativeElement.innerHTML = result;\n          return;\n        }\n      }\n      // if there is no icon with this name warn the user as they probably forgot to import it\n      console.warn(`No icon named ${name} was found. You may need to import it using the withIcons function.`);\n    })();\n  }\n  /**\n   * Request the icon from the loader.\n   * @param name The name of the icon to load.\n   * @returns The SVG content for a given icon name.\n   */\n  requestIconFromLoader(name) {\n    var _this2 = this;\n    return new Promise(resolve => {\n      runInInjectionContext(this.injector, /*#__PURE__*/_asyncToGenerator(function* () {\n        const result = yield coerceLoaderResult(_this2.loader(name));\n        resolve(result);\n      }));\n    });\n  }\n  static #_ = this.ɵfac = function NgIcon_Factory(t) {\n    return new (t || NgIcon)();\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgIcon,\n    selectors: [[\"ng-icon\"]],\n    hostVars: 6,\n    hostBindings: function NgIcon_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"--ng-icon__size\", ctx.size)(\"--ng-icon__stroke-width\", ctx.strokeWidth)(\"color\", ctx.color);\n      }\n    },\n    inputs: {\n      name: \"name\",\n      size: \"size\",\n      strokeWidth: \"strokeWidth\",\n      color: \"color\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function NgIcon_Template(rf, ctx) {},\n    styles: [\"[_nghost-%COMP%]{display:inline-block;width:var(--ng-icon__size);height:var(--ng-icon__size)}\"],\n    changeDetection: 0\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgIcon, [{\n    type: Component,\n    args: [{\n      selector: 'ng-icon',\n      template: '',\n      standalone: true,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      styles: [\":host{display:inline-block;width:var(--ng-icon__size);height:var(--ng-icon__size)}\\n\"]\n    }]\n  }], null, {\n    name: [{\n      type: Input\n    }],\n    size: [{\n      type: HostBinding,\n      args: ['style.--ng-icon__size']\n    }, {\n      type: Input\n    }],\n    strokeWidth: [{\n      type: HostBinding,\n      args: ['style.--ng-icon__stroke-width']\n    }, {\n      type: Input\n    }],\n    color: [{\n      type: HostBinding,\n      args: ['style.color']\n    }, {\n      type: Input\n    }]\n  });\n})();\nfunction coerceCssPixelValue(value) {\n  return value == null ? '' : /^\\d+$/.test(value) ? `${value}px` : value;\n}\nclass NgIconsModule {\n  constructor(icons) {\n    if (Object.keys(icons).length === 0) {\n      throw new Error('No icons have been provided. Ensure to include some icons by importing them using NgIconsModule.withIcons({ ... }).');\n    }\n  }\n  /**\n   * Define the icons that will be included in the application. This allows unused icons to\n   * be tree-shaken away to reduce bundle size\n   * @param icons The object containing the required icons\n   */\n  static withIcons(icons) {\n    return {\n      ngModule: NgIconsModule,\n      providers: provideIcons(icons)\n    };\n  }\n  static #_ = this.ɵfac = function NgIconsModule_Factory(t) {\n    return new (t || NgIconsModule)(i0.ɵɵinject(NgIconsToken));\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgIconsModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgIconsModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NgIcon],\n      exports: [NgIcon]\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NgIconsToken]\n      }]\n    }];\n  }, null);\n})();\nconst NG_ICON_DIRECTIVES = [NgIcon];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NG_ICON_DIRECTIVES, NgIcon, NgIconCacheToken, NgIcon as NgIconComponent, NgIconConfigToken, NgIconLoaderToken, NgIconsModule, NgIconsToken, injectNgIconConfig, injectNgIconLoader, injectNgIconLoaderCache, injectNgIcons, provideIcons, provideNgIconLoader, provideNgIconsConfig, withCaching };","map":{"version":3,"names":["i0","InjectionToken","inject","Optional","SkipSelf","Injector","ElementRef","runInInjectionContext","Component","ChangeDetectionStrategy","Input","HostBinding","NgModule","Inject","isObservable","firstValueFrom","NgIconConfigToken","defaultConfig","size","provideNgIconsConfig","config","provide","useValue","injectNgIconConfig","optional","NgIconLoaderToken","loaderFeature","kind","providers","NgIconCacheToken","withCaching","Map","provideNgIconLoader","loader","features","map","feature","injectNgIconLoader","injectNgIconLoaderCache","provideIcons","icons","NgIconsToken","useFactory","parentIcons","reduce","acc","deps","multi","injectNgIcons","coerceLoaderResult","result","Promise","resolve","toPropertyName","str","replace","_","__","chr","toUpperCase","m","toLowerCase","NgIcon","constructor","cache","injector","elementRef","_size","color","name","setIcon","coerceCssPixelValue","_this","_asyncToGenerator","propertyName","reverse","nativeElement","innerHTML","has","get","requestIconFromLoader","set","console","warn","_this2","ɵfac","NgIcon_Factory","t","_2","ɵcmp","ɵɵdefineComponent","type","selectors","hostVars","hostBindings","NgIcon_HostBindings","rf","ctx","ɵɵstyleProp","strokeWidth","inputs","standalone","ɵɵStandaloneFeature","decls","vars","template","NgIcon_Template","styles","changeDetection","ngDevMode","ɵsetClassMetadata","args","selector","OnPush","value","test","NgIconsModule","Object","keys","length","Error","withIcons","ngModule","NgIconsModule_Factory","ɵɵinject","ɵmod","ɵɵdefineNgModule","_3","ɵinj","ɵɵdefineInjector","imports","exports","undefined","decorators","NG_ICON_DIRECTIVES","NgIconComponent"],"sources":["/home/alha/Project/quikkom-frontend/node_modules/@ng-icons/core/fesm2022/ng-icons-core.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, inject, Optional, SkipSelf, Injector, ElementRef, runInInjectionContext, Component, ChangeDetectionStrategy, Input, HostBinding, NgModule, Inject } from '@angular/core';\nimport { isObservable, firstValueFrom } from 'rxjs';\n\nconst NgIconConfigToken = new InjectionToken('Ng Icon Config');\nconst defaultConfig = {\n    size: '1em',\n};\n/**\n * Provide the configuration for the icons\n * @param config The configuration to use\n */\nfunction provideNgIconsConfig(config) {\n    return {\n        provide: NgIconConfigToken,\n        useValue: { ...defaultConfig, ...config },\n    };\n}\n/**\n * Inject the configuration for the icons\n * @returns The configuration to use\n * @internal\n */\nfunction injectNgIconConfig() {\n    return inject(NgIconConfigToken, { optional: true }) ?? defaultConfig;\n}\n\nconst NgIconLoaderToken = new InjectionToken('Ng Icon Loader Token');\n/**\n * Helper function to create an object that represents a Loader feature.\n */\nfunction loaderFeature(kind, providers) {\n    return { kind: kind, providers: providers };\n}\nconst NgIconCacheToken = new InjectionToken('Ng Icon Cache Token');\n/**\n * Add caching to the loader. This will prevent the loader from being called multiple times for the same icon name.\n */\nfunction withCaching() {\n    return loaderFeature(0 /* NgIconLoaderFeatureKind.CachingFeature */, [\n        { provide: NgIconCacheToken, useValue: new Map() },\n    ]);\n}\n/**\n * Provide a function that will return the SVG content for a given icon name.\n * @param loader The function that will return the SVG content for a given icon name.\n * @param features The list of features to apply to the loader.\n * @returns The SVG content for a given icon name.\n */\nfunction provideNgIconLoader(loader, ...features) {\n    return [\n        { provide: NgIconLoaderToken, useValue: loader },\n        features.map(feature => feature.providers),\n    ];\n}\n/**\n * Inject the function that will return the SVG content for a given icon name.\n */\nfunction injectNgIconLoader() {\n    return inject(NgIconLoaderToken, { optional: true });\n}\n/**\n * Inject the cache that will store the SVG content for a given icon name.\n */\nfunction injectNgIconLoaderCache() {\n    return inject(NgIconCacheToken, { optional: true });\n}\n\n/**\n * Define the icons to use\n * @param icons The icons to provide\n */\nfunction provideIcons(icons) {\n    return [\n        {\n            provide: NgIconsToken,\n            useFactory: (parentIcons) => ({\n                ...parentIcons?.reduce((acc, icons) => ({ ...acc, ...icons }), {}),\n                ...icons,\n            }),\n            deps: [[NgIconsToken, new Optional(), new SkipSelf()]],\n            multi: true,\n        },\n    ];\n}\nconst NgIconsToken = new InjectionToken('Icons Token');\n/**\n * Inject the icons to use\n * @returns The icons to use\n * @internal\n */\nfunction injectNgIcons() {\n    return inject(NgIconsToken, { optional: true }) ?? [];\n}\n\n/**\n * A loader may return a promise, an observable or a string. This function will coerce the result into a promise.\n * @returns\n */\nfunction coerceLoaderResult(result) {\n    if (typeof result === 'string') {\n        return Promise.resolve(result);\n    }\n    if (isObservable(result)) {\n        return firstValueFrom(result);\n    }\n    return result;\n}\n\n/**\n * Hyphenated to lowerCamelCase\n */\nfunction toPropertyName(str) {\n    return str\n        .replace(/([^a-zA-Z0-9])+(.)?/g, (_, __, chr) => chr ? chr.toUpperCase() : '')\n        .replace(/[^a-zA-Z\\d]/g, '')\n        .replace(/^([A-Z])/, m => m.toLowerCase());\n}\n\nclass NgIcon {\n    constructor() {\n        /** Access the global icon config */\n        this.config = injectNgIconConfig();\n        /** Access the icons */\n        this.icons = injectNgIcons();\n        /** Access the icon loader if defined */\n        this.loader = injectNgIconLoader();\n        /** Access the icon loader cache if defined */\n        this.cache = injectNgIconLoaderCache();\n        /** Access the injector */\n        this.injector = inject(Injector);\n        /** Access the element ref */\n        this.elementRef = inject(ElementRef);\n        this._size = this.config.size;\n        /** Define the color of the icon */\n        this.color = this.config.color;\n    }\n    /** Define the name of the icon to display */\n    set name(name) {\n        this.setIcon(name);\n    }\n    /** Define the size of the icon */\n    set size(size) {\n        // if the size only contains numbers, assume it is in pixels\n        this._size = coerceCssPixelValue(size);\n    }\n    get size() {\n        return this._size;\n    }\n    /**\n     * Load the icon with the given name and insert it into the template.\n     * @param name The name of the icon to load.\n     */\n    async setIcon(name) {\n        const propertyName = toPropertyName(name);\n        for (const icons of [...this.icons].reverse()) {\n            if (icons[propertyName]) {\n                // insert the SVG into the template\n                this.elementRef.nativeElement.innerHTML = icons[propertyName];\n                return;\n            }\n        }\n        // if we have a cache check if the icon is already loaded\n        if (this.cache?.has(name)) {\n            this.elementRef.nativeElement.innerHTML = this.cache.get(name);\n            return;\n        }\n        // if there is a loader defined, use it to load the icon\n        if (this.loader) {\n            const result = await this.requestIconFromLoader(name);\n            // if the result is a string, insert the SVG into the template\n            if (result !== null) {\n                // if we have a cache, store the result\n                this.cache?.set(name, result);\n                this.elementRef.nativeElement.innerHTML = result;\n                return;\n            }\n        }\n        // if there is no icon with this name warn the user as they probably forgot to import it\n        console.warn(`No icon named ${name} was found. You may need to import it using the withIcons function.`);\n    }\n    /**\n     * Request the icon from the loader.\n     * @param name The name of the icon to load.\n     * @returns The SVG content for a given icon name.\n     */\n    requestIconFromLoader(name) {\n        return new Promise(resolve => {\n            runInInjectionContext(this.injector, async () => {\n                const result = await coerceLoaderResult(this.loader(name));\n                resolve(result);\n            });\n        });\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: NgIcon, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.2.5\", type: NgIcon, isStandalone: true, selector: \"ng-icon\", inputs: { name: \"name\", size: \"size\", strokeWidth: \"strokeWidth\", color: \"color\" }, host: { properties: { \"style.--ng-icon__size\": \"this.size\", \"style.--ng-icon__stroke-width\": \"this.strokeWidth\", \"style.color\": \"this.color\" } }, ngImport: i0, template: '', isInline: true, styles: [\":host{display:inline-block;width:var(--ng-icon__size);height:var(--ng-icon__size)}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: NgIcon, decorators: [{\n            type: Component,\n            args: [{ selector: 'ng-icon', template: '', standalone: true, changeDetection: ChangeDetectionStrategy.OnPush, styles: [\":host{display:inline-block;width:var(--ng-icon__size);height:var(--ng-icon__size)}\\n\"] }]\n        }], propDecorators: { name: [{\n                type: Input\n            }], size: [{\n                type: HostBinding,\n                args: ['style.--ng-icon__size']\n            }, {\n                type: Input\n            }], strokeWidth: [{\n                type: HostBinding,\n                args: ['style.--ng-icon__stroke-width']\n            }, {\n                type: Input\n            }], color: [{\n                type: HostBinding,\n                args: ['style.color']\n            }, {\n                type: Input\n            }] } });\nfunction coerceCssPixelValue(value) {\n    return value == null ? '' : /^\\d+$/.test(value) ? `${value}px` : value;\n}\n\nclass NgIconsModule {\n    constructor(icons) {\n        if (Object.keys(icons).length === 0) {\n            throw new Error('No icons have been provided. Ensure to include some icons by importing them using NgIconsModule.withIcons({ ... }).');\n        }\n    }\n    /**\n     * Define the icons that will be included in the application. This allows unused icons to\n     * be tree-shaken away to reduce bundle size\n     * @param icons The object containing the required icons\n     */\n    static withIcons(icons) {\n        return { ngModule: NgIconsModule, providers: provideIcons(icons) };\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: NgIconsModule, deps: [{ token: NgIconsToken }], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.2.5\", ngImport: i0, type: NgIconsModule, imports: [NgIcon], exports: [NgIcon] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: NgIconsModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: NgIconsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [NgIcon],\n                    exports: [NgIcon],\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NgIconsToken]\n                }] }]; } });\nconst NG_ICON_DIRECTIVES = [NgIcon];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NG_ICON_DIRECTIVES, NgIcon, NgIconCacheToken, NgIcon as NgIconComponent, NgIconConfigToken, NgIconLoaderToken, NgIconsModule, NgIconsToken, injectNgIconConfig, injectNgIconLoader, injectNgIconLoaderCache, injectNgIcons, provideIcons, provideNgIconLoader, provideNgIconsConfig, withCaching };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}